<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:mx="library://ns.adobe.com/flex/mx"
		  currentState="disconnectedState" xmlns:service="com.antistatus.whatchado.service.*">
	
	<fx:Script>
		<![CDATA[
			import com.antistatus.whatchado.event.SystemEvent;
			import com.antistatus.whatchado.event.VideoRecorderEvent;
			import com.antistatus.whatchado.utilities.Trace;
			
			import org.osmf.net.StreamType;
			
			private static const RECORD_STATE:String = "recordState";
			private static const STOP_STATE:String = "stopState";
			private static const DISCONNECTED_STATE:String = "disconnectedState";
			
			private static const RTMP_SERVER:String = "rtmp://localhost:1935/mytest/";
			private static const BUFFER_TIME:int = 9;
			
			private var connection:NetConnection;
			private var stream:NetStream;
			private var streamName:String;
			private var stopRequested:Boolean;
			
			[Bindable] 
			private var duration:Number = 0;
			[Bindable] 
			private var bufferLength:Number = 0;
			private var startTime:Number;
			public var currentCamera:Camera;
			public var currentMicrophone:Microphone;
			public var currentTake:int = 1;
			public var currentAnswer:int;
									
			private var videoOriginalHeight:int;
			private var videoOriginalWidth:int = 320;
			private var videoHeightRatio:Number;
			private var videoWidthRatio:Number = 240;
			
			public function connect():void
			{
				addEventListener(Event.ENTER_FRAME, updateBufferLength);
				connection = new NetConnection();
				connection.addEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
				connection.connect(RTMP_SERVER);
			}
			
			private function netConnectionStatusHandler(event:NetStatusEvent) : void
			{
				var evCode:String = event.info.code;
				
				dispatchLogEvent("netConnectionStatusHandler::event.info.code = " + evCode + "\n");
				
				switch (evCode)
				{
					case "NetConnection.Connect.Success":
						currentState = STOP_STATE;
						createStream();
						dispatchEvent(new VideoRecorderEvent(VideoRecorderEvent.CONNECTED));
						break;
					
					case "NetStream.Publish.Start":
						startTime = new Date().time;
						addEventListener(Event.ENTER_FRAME, updateRecordTime);
						break;
					
					case "NetStream.Buffer.Empty":
						if (stopRequested)
						{
							stop();
							stopRequested = false;
						}
						break;
					
					case "NetStream.Unpublish.Success":
						saveByPath();
						break;
				}
			}
			
			private function saveByPath() : void
			{
				var source:File = File.applicationStorageDirectory.resolvePath("server/webapps/mytest/streams/" + streamName + ".flv");	
				var destination:File = File.applicationStorageDirectory.resolvePath("recordings/answer"+currentAnswer+"/" + streamName + ".flv");
				source.copyTo(destination);
				source.deleteFile();
				dispatchEvent(new SystemEvent(SystemEvent.VIDEO_RECORDED, 0, true));
				currentTake++;
			}
			
			private function updateRecordTime(e:Event) : void
			{
				duration = new Date().time - startTime;
			}
			
			private function updateBufferLength(e:Event) : void
			{
				if (stream)
					bufferLength = stream.bufferLength;
				else
					bufferLength = -1;
			}
			
			protected function pingServer():void
			{
				connection.call("pingServer", new Responder(res, fault));
				
				function res(e:Object) : void
				{
					dispatchLogEvent("Ping is successfull. Returned value:" + e.toString() + "\n");
				}
				
				function fault(e:Object) : void
				{
					dispatchLogEvent("Ping is failed.\n");
				}
			}
			
			
			private function get cam():Camera
			{
				var camera:Camera = currentCamera;
				camera.setQuality(0, 100);
				camera.setMode(852, 480, 30);
				return camera;
			}
			
			private function onRecord():void 
			{
				currentState = RECORD_STATE;
				
				destroyStream();
				
				if (connection)
				{
					createStream();
					stream.publish(streamName, "record");
				}
			}
			
			private function createStream() : void
			{
				var cam:Camera = this.cam;
				videoDisplay.videoObject.attachCamera(cam);
				setVideoSize(cam.width, cam.height);
				stream = new NetStream(connection);
				stream.addEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
				stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				stream.attachCamera(cam);
				stream.attachAudio(currentMicrophone);
				stream.bufferTime = BUFFER_TIME;
				createStreamName();
				//videoDisplay.source = "rtmp://localhost:1935/mytest/" + streamName;
			}
			
			private function getDateTime():String
			{
				var dateObj:Date = new Date();
				var year:String = String(dateObj.getFullYear());
				var month:String = String(dateObj.getMonth() + 1);
				if (month.length == 1) 
					month = "0"+month;
				
				var date:String = String(dateObj.getDate());
				if (date.length == 1) 
					date = "0"+date;
				
				
				var hours:String = String(dateObj.getHours());
				if (hours.length == 1) 
					hours = "0"+hours;
				var minutes:String = String(dateObj.getMinutes());
				if (minutes.length == 1) 
					minutes = "0"+minutes;
				var seconds:String = String(dateObj.getSeconds());
				if (seconds.length == 1) 
					seconds = "0"+seconds;
				var milli:String = String(dateObj.getMilliseconds());
				return year+""+month+""+date+"-"+hours+"."+minutes+"."+seconds+"."+milli;
			}
			
			private function createStreamName() : void
			{
				streamName = "answer"+ currentAnswer + "take" + currentTake + "_" + getDateTime();
				dispatchLogEvent("Stream name generated: " + streamName + "\n");
			}
			
			private function destroyStream() : void
			{
				if (stream)
				{
					stream.removeEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
					stream.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
					stream.attachCamera(null);
					stream.attachAudio(null);
					stream = null;
				}
			}
			
			public function onStop() : void
			{
				removeEventListener(Event.ENTER_FRAME, updateRecordTime);
				stream.attachCamera(null);
				stream.attachAudio(null);
				stopRequested = true;
			}
			
			private function stop():void 
			{
				currentState = STOP_STATE;
				stream.close();
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void 
			{
				dispatchLogEvent("onSecurityError: " + event + "\n");
			}
			
			private function asyncErrorHandler(event:AsyncErrorEvent):void 
			{
				dispatchLogEvent("onAsyncError: " + event + "\n");
			}
			
			private function dispatchLogEvent(log:String) : void
			{
				Trace.log(this, log);
			}

			private function setVideoSize(w:int, h:int):void
			{
				if (videoOriginalWidth == w && videoOriginalHeight == h)
					return;
				
				videoOriginalWidth = w;
				videoOriginalHeight = h;
				videoWidthRatio = w / h;
				videoHeightRatio = h / w;
				invalidateDisplayList();
			}
			
			public function disconnect():void
			{
				onStop();
			}
			
		]]>
	</fx:Script>
	<s:states>		
		<s:State name="recordState"/>
		<s:State name="stopState"/>	
		<s:State name="disconnectedState"/>	
	</s:states>
	
	<s:Group top="0" bottom="125" left="0" right="0">
		<s:Rect width="100%" height="100%">
			<s:fill>
				<s:SolidColor color="#000000"/>
			</s:fill>
		</s:Rect>
		<s:VideoDisplay id="videoDisplay" scaleX="-1"  width="100%" height="100%">
			<s:source>
				<s:DynamicStreamingVideoSource host="" streamType="{StreamType.LIVE}">
					<s:DynamicStreamingVideoItem  />
				</s:DynamicStreamingVideoSource>
			</s:source>
		</s:VideoDisplay>
	</s:Group>
	<s:Button id="rBtn" 
			  width="80" height="80"
			  label="Record" 
			  fontSize="16"
			  fontWeight="bold"
			  enabled.recordState="false"
			  enabled.disconnectedState="false"
			  click="onRecord()" />
	<s:Label text="{(duration/1000).toPrecision(2)}" 
			 width="80"
			 textAlign="center"
			 fontWeight="bold" 
			 color="red"
			 fontSize="16"/>
	<s:Label text="{bufferLength.toPrecision(2)}/{BUFFER_TIME}" 
			 width="80"
			 textAlign="center"
			 fontWeight="bold" 
			 color="red"
			 fontSize="16"/>
	<s:Spacer height="100%"/>
	<s:Button id="sBtn" 
			  width="80" height="40"
			  label="Stop" 
			  fontSize="12"
			  fontWeight="bold"
			  enabled.stopState="false"
			  enabled.disconnectedState="false"
			  click="onStop()" />
	
</s:Group>
