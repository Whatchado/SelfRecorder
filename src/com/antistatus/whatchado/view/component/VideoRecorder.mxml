<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:mx="library://ns.adobe.com/flex/mx"
		  currentState="disconnectedState" xmlns:service="com.antistatus.whatchado.service.*">
	
	<fx:Script>
		<![CDATA[
			import com.antistatus.whatchado.event.VideoRecorderEvent;
			import com.antistatus.whatchado.event.ViewEvent;
			import com.antistatus.whatchado.utilities.Trace;
			
			import org.osmf.net.StreamType;
			
			private static const RECORD_STATE:String = "recordState";
			private static const STOP_STATE:String = "stopState";
			private static const DISCONNECTED_STATE:String = "disconnectedState";
			
			private static const RTMP_SERVER:String = "rtmp://localhost:1935/mytest/";
			private static const BUFFER_TIME:int = 1;
			
			private var connection:NetConnection;
			private var stream:NetStream;
			private var streamName:String;
			private var stopRequested:Boolean;
			
			private var bufferLength:Number = 0;
			private var startTime:Number;
			public var currentCamera:Camera;
			public var currentMicrophone:Microphone;
			public var currentTake:int = 1;
			public var currentAnswer:int;
			public var mode:String = "";
									
			private var videoOriginalHeight:int;
			private var videoOriginalWidth:int = 320;
			private var videoHeightRatio:Number;
			private var videoWidthRatio:Number = 240;
			private var sec:Number;
			
			public function connect():void
			{
				addEventListener(Event.ENTER_FRAME, updateBufferLength);
				connection = new NetConnection();
				connection.addEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
				connection.connect(RTMP_SERVER);
			}
			
			private function netConnectionStatusHandler(event:NetStatusEvent) : void
			{
				var evCode:String = event.info.code;
				
				dispatchLogEvent("netConnectionStatusHandler::event.info.code = " + evCode + "\n");
				
				switch (evCode)
				{
					case "NetConnection.Connect.Success":
						currentState = STOP_STATE;
						createStream();
						dispatchEvent(new VideoRecorderEvent(VideoRecorderEvent.CONNECTED));
						break;
					
					case "NetStream.Publish.Start":
						startTime = new Date().time;
						addEventListener(Event.ENTER_FRAME, updateRecordTime);
						break;
					
					case "NetStream.Buffer.Empty":
						if (stopRequested)
						{
							stop();
							stopRequested = false;
						}
						break;
					
					case "NetStream.Unpublish.Success":
						saveByPath();
						break;
				}
			}
			
			private function saveByPath() : void
			{
				var source:File = File.applicationStorageDirectory.resolvePath("server/webapps/mytest/streams/" + streamName + ".flv");
				
				var destination:File;
				if(mode == "test")
					destination= File.applicationStorageDirectory.resolvePath("testrecording/test.flv");
				else
					destination= File.applicationStorageDirectory.resolvePath("recordings/answer"+currentAnswer+"/" + streamName + ".flv");
				
				if(source.exists)
				{
					source.copyTo(destination, true);
					source.deleteFile();
				}
				dispatchEvent(new ViewEvent(ViewEvent.VIDEO_RECORDED, {file: streamName + ".flv"}, true));
				currentTake++;
			}
			
			private function updateRecordTime(e:Event) : void
			{
				durationView.text = getTimeString(new Date().time - startTime);
			}
			
			private function updateBufferLength(e:Event) : void
			{
				if (stream)
					bufferLength = stream.bufferLength;
				else
					bufferLength = -1;
			}
			
			protected function pingServer():void
			{
				connection.call("pingServer", new Responder(res, fault));
				
				function res(e:Object) : void
				{
					dispatchLogEvent("Ping is successfull. Returned value:" + e.toString() + "\n");
				}
				
				function fault(e:Object) : void
				{
					dispatchLogEvent("Ping is failed.\n");
				}
			}
			
			
			private function get cam():Camera
			{
				var camera:Camera = currentCamera;
				camera.setQuality(0, 100);
				camera.setMode(852, 480, 25, false);
				return camera;
			}
			
			private function onRecord():void 
			{
				currentState = RECORD_STATE;
				
				destroyStream();
				
				if (connection)
				{
					createStream();
					stream.publish(streamName, "record");
				}
			}
			
			private function createStream() : void
			{
				var cam:Camera = this.cam;
				videoDisplay.videoObject.attachCamera(cam);
				setVideoSize(cam.width, cam.height);
				stream = new NetStream(connection);
				stream.addEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
				stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				stream.attachCamera(cam);
				stream.attachAudio(currentMicrophone);
				stream.bufferTime = BUFFER_TIME;
				var h264Settings:H264VideoStreamSettings = new H264VideoStreamSettings();
				h264Settings.setProfileLevel(H264Profile.BASELINE, H264Level.LEVEL_3_1);
				stream.videoStreamSettings = h264Settings;
				createStreamName();
				//videoDisplay.source = "rtmp://localhost:1935/mytest/" + streamName;
			}
			
			private function getDateTime():String
			{
				var dateObj:Date = new Date();
				var year:String = String(dateObj.getFullYear());
				var month:String = String(dateObj.getMonth() + 1);
				if (month.length == 1) 
					month = "0"+month;
				
				var date:String = String(dateObj.getDate());
				if (date.length == 1) 
					date = "0"+date;
				
				
				var hours:String = String(dateObj.getHours());
				if (hours.length == 1) 
					hours = "0"+hours;
				var minutes:String = String(dateObj.getMinutes());
				if (minutes.length == 1) 
					minutes = "0"+minutes;
				var seconds:String = String(dateObj.getSeconds());
				if (seconds.length == 1) 
					seconds = "0"+seconds;
				var milli:String = String(dateObj.getMilliseconds());
				return year+""+month+""+date+"-"+hours+"."+minutes+"."+seconds+"."+milli;
			}
			
			private function createStreamName() : void
			{
				if(mode == "test")
					streamName = "test";
				else					
					streamName = currentAnswer + "_" + currentTake + "_" + getDateTime();
		
				dispatchLogEvent("Stream name generated: " + streamName + "\n");
			}
			
			private function destroyStream() : void
			{
				if (stream)
				{
					stream.removeEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
					stream.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
					stream.attachCamera(null);
					stream.attachAudio(null);
					stream = null;
				}
			}
			
			public function onStop() : void
			{
				removeEventListener(Event.ENTER_FRAME, updateRecordTime);
				stream.attachCamera(null);
				stream.attachAudio(null);
				stopRequested = true;
			}
			
			private function stop():void 
			{
				currentState = STOP_STATE;
				stream.close();
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void 
			{
				dispatchLogEvent("onSecurityError: " + event + "\n");
			}
			
			private function asyncErrorHandler(event:AsyncErrorEvent):void 
			{
				dispatchLogEvent("onAsyncError: " + event + "\n");
			}
			
			private function dispatchLogEvent(log:String) : void
			{
				Trace.log(this, log);
			}

			private function setVideoSize(w:int, h:int):void
			{
				if (videoOriginalWidth == w && videoOriginalHeight == h)
					return;
				
				videoOriginalWidth = w;
				videoOriginalHeight = h;
				videoWidthRatio = w / h;
				videoHeightRatio = h / w;
				invalidateDisplayList();
			}
			
			public function disconnect():void
			{
				onStop();
			}
			
			private function getTimeString(milli:Number):String
			{
				sec = milli/1000;
				var s:Number = sec % 60;
				var m:Number = Math.floor((sec % 3600 ) / 60);
				var h:Number = Math.floor(sec / (60 * 60));
				
				var hourStr:String = (h == 0) ? "" : doubleDigitFormat(h) + ":";
				var minuteStr:String = doubleDigitFormat(m) + ":";
				var secondsStr:String = doubleDigitFormat(s);
				
				return hourStr + minuteStr + secondsStr;
			}
			
			private function doubleDigitFormat($num:uint):String
			{
				if ($num < 10) 
				{
					return ("0" + $num);
				}
				return String($num);
			}
				
			
		]]>
	</fx:Script>
	<s:states>		
		<s:State name="recordState"/>
		<s:State name="stopState"/>	
		<s:State name="disconnectedState"/>	
	</s:states>
	
	<s:Group top="0" bottom="125" left="0" right="0">
		<s:Rect width="100%" height="100%">
			<s:fill>
				<s:SolidColor color="#000000"/>
			</s:fill>
		</s:Rect>
		<s:VideoDisplay id="videoDisplay" scaleX="-1" left="0" right="0" top="0" bottom="0">
			<s:source>
				<s:DynamicStreamingVideoSource host="" streamType="{StreamType.LIVE}">
					<s:DynamicStreamingVideoItem  />
				</s:DynamicStreamingVideoSource>
			</s:source>
		</s:VideoDisplay>
	</s:Group>
	
	<s:BitmapImage bottom="0" horizontalCenter="0" width="148"  height="125" 
				   source="@Embed(source='../assets/skin/recordingButton.png')" 
				   excludeFrom="recordState" alpha.disconnectedState=".5"/>
	
	<s:BitmapImage bottom="0" horizontalCenter="0" width="148" height="125" source="@Embed(source='../assets/skin/recordingButtonRec.png')" includeIn="recordState"/>
	<!--/{bufferLength.toPrecision(2)}/{BUFFER_TIME}-->
	<s:Label id="durationView"  includeIn="recordState"
			 width="180"
			 textAlign="center"
			 fontWeight="bold" fontSize="20"
			 color="#FFFFFF"
			 horizontalCenter="0" 
			 bottom="55">
		<s:filters>
			<s:DropShadowFilter distance="1" strength=".5"/>
		</s:filters>
	</s:Label>
	<s:Button id="rBtn" skinClass="com.antistatus.whatchado.view.skin.EmptyButtonSkin" buttonMode="true" useHandCursor="true"
			  horizontalCenter="0" width="148" height="125" bottom="0"
			  enabled.disconnectedState="false"
			  click="onRecord()" click.recordState="onStop()"/>
	

</s:Group>
