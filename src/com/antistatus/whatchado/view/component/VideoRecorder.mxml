<?xml version="1.0" encoding="utf-8"?>
<s:HGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:mx="library://ns.adobe.com/flex/mx"
		  currentState="disconnectedState" xmlns:service="com.antistatus.whatchado.service.*" creationComplete="creationCompleteHandler(event)">
	
	<fx:Script>
		<![CDATA[
			import com.antistatus.whatchado.event.SystemEvent;
			import com.antistatus.whatchado.event.VideoRecorderEvent;
			import com.antistatus.whatchado.service.ConfigurationManager;
			import com.antistatus.whatchado.utilities.Trace;
			
			import mx.events.FlexEvent;
			
			import org.osmf.net.StreamType;
			
			private static const RECORD_STATE:String = "recordState";
			private static const STOP_STATE:String = "stopState";
			private static const DISCONNECTED_STATE:String = "disconnectedState";
			
			private static const RTMP_SERVER:String = "rtmp://localhost:1935/mytest/";
			private static const BUFFER_TIME:int = 9;
			
			private var connection:NetConnection;
			private var stream:NetStream;
			private var streamName:String;
			private var stopRequested:Boolean;
			
			[Bindable] 
			private var duration:Number = 0;
			[Bindable] 
			private var bufferLength:Number = 0;
			private var startTime:Number;
			public var currentCamera:Camera;
			public var currentMicrophone:Microphone;
			public var currentTake:int = 1;
			public var currentAnswer:int;
									
			public function connect():void
			{
				addEventListener(Event.ENTER_FRAME, updateBufferLength);
				connection = new NetConnection();
				connection.addEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
				connection.connect(RTMP_SERVER);
			}
			
			private function netConnectionStatusHandler(event:NetStatusEvent) : void
			{
				var evCode:String = event.info.code;
				
				dispatchLogEvent("netConnectionStatusHandler::event.info.code = " + evCode + "\n");
				
				switch (evCode)
				{
					case "NetConnection.Connect.Success":
						currentState = STOP_STATE;
						createStream();
						dispatchEvent(new VideoRecorderEvent(VideoRecorderEvent.CONNECTED));
						break;
					
					case "NetStream.Publish.Start":
						startTime = new Date().time;
						addEventListener(Event.ENTER_FRAME, updateRecordTime);
						break;
					
					case "NetStream.Buffer.Empty":
						if (stopRequested)
						{
							stop();
							stopRequested = false;
						}
						break;
					
					case "NetStream.Unpublish.Success":
						saveByPath();
						break;
				}
			}
			
			private function saveByPath() : void
			{
				var source:File = File.applicationDirectory.resolvePath("server/webapps/mytest/streams/" + streamName + ".flv");	
				var destination:File = File.applicationStorageDirectory.resolvePath("recordings/answer"+currentAnswer+"/" + streamName + ".flv");
				source.copyTo(destination);
				//source.deleteFile();
				dispatchEvent(new SystemEvent(SystemEvent.VIDEO_RECORDED));
				currentTake++;
			}
			
			private function updateRecordTime(e:Event) : void
			{
				duration = new Date().time - startTime;
			}
			
			private function updateBufferLength(e:Event) : void
			{
				if (stream)
					bufferLength = stream.bufferLength;
				else
					bufferLength = -1;
			}
			
			protected function pingServer():void
			{
				connection.call("pingServer", new Responder(res, fault));
				
				function res(e:Object) : void
				{
					dispatchLogEvent("Ping is successfull. Returned value:" + e.toString() + "\n");
				}
				
				function fault(e:Object) : void
				{
					dispatchLogEvent("Ping is failed.\n");
				}
			}
			
			
			private function get cam():Camera
			{
				var camera:Camera = currentCamera;
				camera.setQuality(0, 100);
				camera.setMode(852, 480, 30);
				return camera;
			}
			
			private function onRecord():void 
			{
				currentState = RECORD_STATE;
				
				destroyStream();
				
				if (connection)
				{
					createStream();
					stream.publish(streamName, "record");
				}
			}
			
			private function createStream() : void
			{
				var cam:Camera = this.cam;
				videoDisplay.videoObject.attachCamera(cam);
				stream = new NetStream(connection);
				stream.addEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
				stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				stream.attachCamera(cam);
				stream.attachAudio(currentMicrophone);
				stream.bufferTime = BUFFER_TIME;
				createStreamName();
				//videoDisplay.source = "rtmp://localhost:1935/mytest/" + streamName;
			}
			
			private function getDateTime():String
			{
				var dateObj:Date = new Date();
				var year:String = String(dateObj.getFullYear());
				var month:String = String(dateObj.getMonth() + 1);
				if (month.length == 1) 
					month = "0"+month;
				
				var date:String = String(dateObj.getDate());
				if (date.length == 1) 
					date = "0"+date;
				
				
				var hours:String = String(dateObj.getHours());
				if (hours.length == 1) 
					hours = "0"+hours;
				var minutes:String = String(dateObj.getMinutes());
				if (minutes.length == 1) 
					minutes = "0"+minutes;
				var seconds:String = String(dateObj.getSeconds());
				if (seconds.length == 1) 
					seconds = "0"+seconds;
				var milli:String = String(dateObj.getMilliseconds());
				return year+""+month+""+date+"-"+hours+"."+minutes+"."+seconds+"."+milli;
			}
			
			private function createStreamName() : void
			{
				streamName = "answer"+ currentAnswer + "take" + currentTake + "_" + getDateTime();
				dispatchLogEvent("Stream name generated: " + streamName + "\n");
			}
			
			private function destroyStream() : void
			{
				if (stream)
				{
					stream.removeEventListener(NetStatusEvent.NET_STATUS, netConnectionStatusHandler);
					stream.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
					stream.attachCamera(null);
					stream.attachAudio(null);
					stream = null;
				}
			}
			
			private function onStop() : void
			{
				removeEventListener(Event.ENTER_FRAME, updateRecordTime);
				stream.attachCamera(null);
				stream.attachAudio(null);
				stopRequested = true;
			}
			
			private function stop():void 
			{
				currentState = STOP_STATE;
				stream.close();
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void 
			{
				dispatchLogEvent("onSecurityError: " + event + "\n");
			}
			
			private function asyncErrorHandler(event:AsyncErrorEvent):void 
			{
				dispatchLogEvent("onAsyncError: " + event + "\n");
			}
			
			private function dispatchLogEvent(log:String) : void
			{
				Trace.log(this, log);
			}
			
			private function red5Started(event:Event):void
			{
				Trace.log(this, "red5 Server has started. Connecting stream...");
				connect();
			}
			private function red5Stopped(event:Event):void
			{
				Trace.log(this, "red5 Server has stopped!");
			}
			private function red5Logging(e:DataEvent):void
			{
				Trace.log(this, e.data);
			}
			
			protected function creationCompleteHandler(event:FlexEvent):void
			{
				ConfigurationManager.getInst().addEventListener("configured", startApp);
				ConfigurationManager.getInst().check();
				function startApp() : void
				{
					red5Starter.start();
				}
			}
			
		]]>
	</fx:Script>
	<fx:Declarations>
		<service:Red5Manager id="red5Starter" logging="red5Logging(event)" started="red5Started(event)" stopped="red5Stopped(event)"/>
	</fx:Declarations>
	
	<s:states>		
		<s:State name="recordState"/>
		<s:State name="stopState"/>	
		<s:State name="disconnectedState"/>	
	</s:states>
	
	<s:VideoDisplay id="videoDisplay" width="640" height="480">
		<s:source>
			<s:DynamicStreamingVideoSource host="" streamType="{StreamType.LIVE}">
				<s:DynamicStreamingVideoItem  />
			</s:DynamicStreamingVideoSource>
		</s:source>
	</s:VideoDisplay>
	<s:VGroup height="100%">
		<s:Button id="rBtn" 
				  width="80" height="80"
				  label="Record" 
				  fontSize="16"
				  fontWeight="bold"
				  enabled.recordState="false"
				  enabled.disconnectedState="false"
				  click="onRecord()" />
		<s:Label text="{(duration/1000).toPrecision(2)}" 
				 width="80"
				 textAlign="center"
				 fontWeight="bold" 
				 color="red"
				 fontSize="16"/>
		<s:Label text="{bufferLength.toPrecision(2)}/{BUFFER_TIME}" 
				 width="80"
				 textAlign="center"
				 fontWeight="bold" 
				 color="red"
				 fontSize="16"/>
		<s:Spacer height="100%"/>
		<s:Button id="sBtn" 
				  width="80" height="40"
				  label="Stop" 
				  fontSize="12"
				  fontWeight="bold"
				  enabled.stopState="false"
				  enabled.disconnectedState="false"
				  click="onStop()" />
	</s:VGroup>
	
</s:HGroup>
